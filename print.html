<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { } 
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li><a href="ch00-00-introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><a href="ch01-00-key-concepts.html"><strong aria-hidden="true">2.</strong> Key Concepts</a></li><li><ol class="section"><li><a href="ch01-01-flat-tree.html"><strong aria-hidden="true">2.1.</strong> Flat Tree</a></li><li><a href="ch01-02-bitfield.html"><strong aria-hidden="true">2.2.</strong> Bitfield</a></li><li><a href="ch01-03-merkle-tree.html"><strong aria-hidden="true">2.3.</strong> Merkle Tree</a></li><li><a href="ch01-04-storage.html"><strong aria-hidden="true">2.4.</strong> Storage</a></li></ol></li><li><a href="ch02-00-implementation-guide.html"><strong aria-hidden="true">3.</strong> Implementation Guide</a></li><li><a href="ch01-00-appendix.html"><strong aria-hidden="true">4.</strong> Appendix</a></li><li><ol class="section"><li><a href="ch01-01-terminology.html"><strong aria-hidden="true">4.1.</strong> A - Terminology</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title"></h1> 

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <a class="header" href="#introduction" id="introduction"><h1>Introduction</h1></a>
<p>Welcome to <em>The Dat Protocol</em>, a technical book about <a href="https://datproject.org/">The Dat
Project</a>. The Dat protocol is a p2p hypermedia
protocol. It provides public-key-addressed file archives which can be synced
securely and browsed on-demand.</p>
<a class="header" href="#who-this-book-is-for" id="who-this-book-is-for"><h2>Who This Book Is For</h2></a>
<p>This book is written for people interested in understanding the details of the
Dat protocol, and potentially implementing parts of it themselves. We go into
details about the different components that make up the protocol, and provide
guidance on how to approach an implementation yourself.</p>
<p>This book is different from the <a href="https://www.datprotocol.com/deps/">Dat Enhancement Proposals
(DEPs)</a>. DEPs focus on creating
standardization and specification of the Dat protocol. This book focuses on
providing an introduction to key concepts, and guidance on how to implement
them.</p>
<a class="header" href="#source-code" id="source-code"><h2>Source Code</h2></a>
<p>The source files from which this book is generated can be found on
<a href="https://github.com/datprotocol/book">GitHub</a>.</p>
<a class="header" href="#key-concepts" id="key-concepts"><h1>Key Concepts</h1></a>
<p>In this section we'll introduce you to the conceptual components that make up
the Dat protocol. You don't need to know these to create your first Dat archive,
but they're essential if you're trying to understand what happens at the
protocol level.</p>
<a class="header" href="#flat-tree" id="flat-tree"><h1>Flat Tree</h1></a>
<p>Flat Trees are the core data structure that powers the Dat protocol.</p>
<a class="header" href="#thinking-about-flat-trees" id="thinking-about-flat-trees"><h2>Thinking About Flat Trees</h2></a>
<p>You can represent a binary tree in a simple flat list using the following
structure:</p>
<pre><code class="language-txt">      3
  1       5
0   2   4   6  ...
</code></pre>
<p>Let's rotate the tree on its side for notational purposes:</p>
<pre><code class="language-txt"> 0─┐
   1─┐
 2─┘ │
     3
 4─┐ │
   5─┘
 6─┘
</code></pre>
<p>Each number represents an <strong>index</strong> in a flat list. Given the tree:</p>
<pre><code class="language-txt"> D─┐
   B─┐
 E─┘ │
     A
 F─┐ │
   C─┘
 G─┘
</code></pre>
<p>The way this would be expressed in-memory would be as the list (vector):
<code>[D B E A F C G]</code> or <code>[0 1 2 3 4 5 6]</code>.</p>
<a class="header" href="#depth" id="depth"><h2>Depth</h2></a>
<p>Indexes 0, 2, 4, 6 have a depth of 0. And indexes 1, 5, 9 have a depth of 1.</p>
<pre><code class="language-text">depth = 2  ^        3
depth = 1  |    1       5
depth = 0  |  0   2   4   6  ...
</code></pre>
<p>If we convert the graph to a chart we could express it as such:</p>
<pre><code class="language-text">depth = 0 | 0 2 4 6
depth = 1 | 1 5
depth = 2 | 3
depth = 3 |
</code></pre>
<p>Now let's add numbers up to 14:</p>
<pre><code class="language-text">depth = 0 | 0 2 4 6 8 10 12 14
depth = 1 | 1 5 9 13
depth = 2 | 3 11
depth = 3 | 7
</code></pre>
<a class="header" href="#node-kinds" id="node-kinds"><h3>Node Kinds</h3></a>
<p>You might be noticing that the numbers at <code>depth = 0</code> is vastly greater than the
amount of numbers at every other depth. We refer to nodes at <code>depth = 0</code> as
<code>leaf nodes</code>, and nodes at every other depth as <code>parent nodes</code>.</p>
<pre><code class="language-text">leaf nodes   | 0 2 4 6 8 10 12 14
parent nodes | 1 3 5 7 9 11 13
</code></pre>
<p>An interesting aspect of flat trees is that the number of <code>leaf nodes</code> and
number of <code>parent nodes</code> is in perfect balance. This comes to an interesting
insight:</p>
<ul>
<li>All <strong>even indexes</strong> refer to <code>leaf nodes</code>.</li>
<li>All <strong>uneven indexes</strong> refer to <code>parent nodes</code>.</li>
</ul>
<p>The depth of a tree node can be calculated by counting the number of trailing 1s
a node has in binary notation.</p>
<pre><code class="language-txt">5 in binary = 101 (one trailing 1)
3 in binary = 011 (two trailing 1s)
4 in binary = 100 (zero trailing 1s)
</code></pre>
<a class="header" href="#offset" id="offset"><h2>Offset</h2></a>
<p>When reading about flat-trees the word <code>offset</code> might regularly pop up. This
refers to the offset from the left hand side of the tree.</p>
<p>In the following tree the indexes with an offset of 0 are: <code>[0 1 3 7]</code>:</p>
<pre><code class="language-text">(0)┐
  (1)┐
 2─┘ │
    (3)┐
 4─┐ │ │
   5─┘ │
 6─┘   │
      (7)
</code></pre>
<p>In the next tree the indexes with an offset of 1 are: <code>[2 5 11]</code>:</p>
<pre><code class="language-text">  0──┐
     1──┐
 (2)─┘  │
        3──┐
  4──┐  │  │
    (5)─┘  │
  6──┘     │
           7
  8──┐     │
     9──┐  │
 10──┘  │  │
      (11)─┘
 12──┐  │
    13──┘
 14──┘
</code></pre>
<a class="header" href="#relationships-between-nodes" id="relationships-between-nodes"><h2>Relationships Between Nodes</h2></a>
<p>When describing nodes we often also talk about the relationship between nodes.
This includes words such as <code>uncle</code>, and <code>parent</code>.</p>
<p>Take this example tree:</p>
<pre><code class="language-txt"> 0─┐
   1─┐
 2─┘ │
     3─┐
 4─┐ │ │
   5─┘ │
 6─┘   │
       7
 8
</code></pre>
<ul>
<li><strong>parent:</strong> A parent has two children under it, and is always odd-numbered.
Node 3 is the parent of 1 and 5.</li>
<li><strong>leaf:</strong> A node with no children. A leaf node is always even-numbered.
Nodes 0, 2, 4, 6 and 8 are leaf nodes.</li>
<li><strong>sibling:</strong> The other node that shares a parent with the current node. For
example nodes 4 and 6 are siblings.</li>
<li><strong>uncle:</strong> A parent's sibling. Node 1 is the uncle of nodes 4 and 6.</li>
<li><strong>root:</strong> A top-most node where the full tree under it is complete (e.g. all
parent nodes have 2 children). Node 3 is a root node.</li>
<li><strong>span:</strong> The two nodes that are furthest away in the sub-tree. The span of
node 1 is <code>0, 2</code>. The span of node 3 is <code>0, 6</code>.</li>
<li><strong>right span:</strong> The left-most node in the span. The right span of node 1 is 2.
The right span of node 3 is 6.</li>
</ul>
<a class="header" href="#references" id="references"><h2>References</h2></a>
<ul>
<li>https://gist.github.com/jimpick/54adc72f11f38f1fe4bc1d45d3981708</li>
<li>https://github.com/jimpick/hypercore-simple-ipld/blob/master/tree-test.js</li>
<li>https://datatracker.ietf.org/doc/rfc7574/?include_text=1</li>
<li>https://www.datprotocol.com/deps/0002-hypercore/</li>
</ul>
<a class="header" href="#bitfield" id="bitfield"><h1>Bitfield</h1></a>
<a class="header" href="#what-is-a-bitfield" id="what-is-a-bitfield"><h2>What is a bitfield?</h2></a>
<p>Space-efficient data structure used to figure out which data you have and what
data you don't. Meant to always be kept in memory because it's small enough.</p>
<p>At its core, bitfields are a way of efficiently describing sets of numbers. You
can think of them as a series of bits. When a number at a position is 1, it
means that position is in the set. If a number is 0, that position isn't.</p>
<a class="header" href="#example" id="example"><h3>Example</h3></a>
<pre><code class="language-txt">bits:  00101
index: 01234
</code></pre>
<p>The set above contains <code>2</code> and <code>4</code>. It's stored left to right, because that's
the way it's enumerated.</p>
<p>In Dat we use bitfields to describe which pieces of data we have, and which
pieces of data we don't. Also it's used internally to index data structures,
such as the Merkle Tree.</p>
<a class="header" href="#indexed-bitfields" id="indexed-bitfields"><h2>Indexed Bitfields</h2></a>
<p>The most common operations in Dat for bitfields is to either find a piece of
data that's missing, or checking if we have a piece of data.</p>
<p>Checking if we have a piece of data is straightforward, as all we have to do is
look in the bitfield in the position of the data and see if it's a <code>1</code>.</p>
<p>Finding a piece of data we're missing is a bit more tricky. Basically it'll
require a linear scan of the whole bitfield. In order to speed this up, we use
an Indexed Bitfield.</p>
<a class="header" href="#structure" id="structure"><h3>Structure</h3></a>
<p>At a high level Indexed Bitfields are a binary tree structure where each node is
made up out of 2 bits.</p>
<ul>
<li><code>11</code> indicates all bits under this node are <code>1</code>s.</li>
<li><code>00</code> indicates all bits under this node are <code>0</code>s.</li>
<li><code>10</code> indicates bits under this node are a mixture of <code>1</code>s and <code>0</code>s.</li>
<li><code>01</code> is currently unused and reserved for (possible) future purposes.</li>
</ul>
<p>We call this the Tree Index Scheme.</p>
<p>Consider this Indexed Bitfield, written as a sequence of bits:</p>
<pre><code class="language-txt">01011101000000
</code></pre>
<p>If we take the same bits and express it as a flat tree, it looks like this:</p>
<pre><code class="language-txt">       01
  01       00
01  11   00  00
</code></pre>
<p>There's a fun implication here: a completely zeroed-out buffer is a valid
Indexed Bitfield - it just means it's completely empty. Even if you express it
as a tree.</p>
<a class="header" href="#optimizing-the-structure" id="optimizing-the-structure"><h3>Optimizing the Structure</h3></a>
<p>Looking at a byte and looking at a bit is the same cost in a computer. You want
to optimize for getting the most information possible when looking at a byte.</p>
<p>Therefore in order get the most performance out of our structure, we want to
construct our tree using bytes instead of pairs of bits.</p>
<p>Consider the following scheme. Given two bytes: <code>A</code> <code>B</code>. Take each of them, and
split each of them into pairs of two bits. We'll use <code>a1 a2 a3 a4</code> to indicate
the pairs in <code>A</code>. And <code>b1 b2 b3 b4</code> to indicate the pairs in <code>B</code>.</p>
<p>The parent of <code>A</code> and <code>B</code> is <code>C</code>. <code>C</code> is constructed by applying the Tree Index
Scheme to each pair of bits.</p>
<pre><code class="language-txt">                [a1 + a2, a3 + a4, b1 + b2, b3 + b4]
[a1, a2, a3, a4]                                    [b1, b2, b3, b4]
</code></pre>
<p>In the example above, we use the <code>+</code> operator to indicate the application of the
Tree Index Scheme.</p>
<p>In the future we might make this even more efficient using <code>SIMD</code> instructions,
which can operate on more bits at the same time.</p>
<a class="header" href="#lookup-tables" id="lookup-tables"><h2>Lookup Tables</h2></a>
<p>An efficient implementation of the previous scheme can be done using lookup
tables for values between between 0 and 256.</p>
<p>This is all solely for performance and completely optional. The important part
is that the indexing scheme is followed.</p>
<a class="header" href="#types-of-bitfields" id="types-of-bitfields"><h2>Types of Bitfields</h2></a>
<p>We have 3 bitfields:</p>
<ul>
<li><strong>Data Bitfield:</strong> Indicates which data you have, and which data you don't.</li>
<li><strong>Indexed Bitfield:</strong> Helps efficiently search through the Data Bitfield using
the Tree Index Scheme.</li>
<li><strong>Merkle Tree Bitfield:</strong> Indicates which nodes in the Merkle Tree you have,
and which nodes you don't.</li>
</ul>
<p>This means that whenever you update the Data Bitfield, you must also update
the Indexed Bitfield.</p>
<a class="header" href="#updating-a-byte" id="updating-a-byte"><h3>Updating a Byte</h3></a>
<p>If we want to set an index in a bitfield to <code>false</code>, it would mean we needed to
flip a bit to <code>0</code>. Because we can only operate on bytes, the easiest way to
achieve this is to apply a bitmask.</p>
<p>If you consider the following lookup table, in binary notation:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let data_update = vec![
  0b01111111, // 127
  0b10111111, // 191
  0b11011111, // 223
  0b11101111, // 223
  0b11110111, // 247
  0b11111011, // 251
  0b11111101, // 253
  0b11111110, // 254
];
#}</code></pre></pre>
<p>If you take a byte, and you take the lookup table for the bit you want to flip,
you can bitwise <code>&amp;</code> them together to set the bit to zero.</p>
<a class="header" href="#serialization" id="serialization"><h2>Serialization</h2></a>
<p>For every piece of data there's going to be 1 bit in the Data Bitfield. And
2 bits in the Merkle Tree Bitfield because there's a parent node and a leaf
node. There are going to be as many parents as there will be leaves.</p>
<p>Every time there's 16 bits in the Data Bitfield, the Indexed Bitfield needs 2
bits to indicate if it's all <code>1</code>s, <code>0</code>s, or a mixture. And 2 bits for the Tree
Index Scheme, totalling 4 bits in the Indexed Bitfield.</p>
<p>So this translates to the following ratios:</p>
<ul>
<li><strong>Data:</strong> 1024 bytes.</li>
<li><strong>Merkle Tree:</strong> 2048 bytes.</li>
<li><strong>Indexed Tree:</strong> 256 bytes.</li>
</ul>
<a class="header" href="#run-length-encoding" id="run-length-encoding"><h2>Run Length Encoding</h2></a>
<p>When sending data over the wire, we want to compress the bitfields further. An
efficient way of doing this is by using Run Length Encoding (RLE).
TODO: explain the module. For now read the README.</p>
<ul>
<li>https://github.com/mafintosh/bitfield-rle</li>
</ul>
<a class="header" href="#merkle-tree" id="merkle-tree"><h1>Merkle Tree</h1></a>
<p>The format of the each node in the Merkle Tree on disk is a series of 40 byte
buffers. The first 32 bytes is the hash. The next 8 bytes is the byte size of
the spanning tree.</p>
<pre><code class="language-txt">  0──┐
     1──┐
  2──┘  │
        3──┐
  4──┐  │  │
     5──┘  │
  6──┘     │
           7
  8──┐
     9
 10──┘
</code></pre>
<a class="header" href="#storage-format" id="storage-format"><h2>Storage Format</h2></a>
<p>The format for storing nodes is:</p>
<ul>
<li>32 byte header which starts with a magic number to indicate what type of file
it is.</li>
<li>Then a series of nodes, where each index in the sequence corresponds to a
position in the Flat Tree.</li>
</ul>
<p>To read the 6th node from disk (flat tree node <code>#5</code>), you'd use an offset into
the file of <code>32 + 5 * 40</code>, and then read <code>40</code> bytes. The first 32 bytes are the
hash. The last 8 bytes is the combined length of the data nodes <code>#4</code> and <code>#6</code> are
referencing. The length is encoded as <code>uint64</code> Big Endian.</p>
<a class="header" href="#storage" id="storage"><h1>Storage</h1></a>
<p>You can represent a binary tree in a simple flat list using the following
structure:</p>
<pre><code class="language-txt">      3
  1       5
0   2   4   6  ...
</code></pre>
<a class="header" href="#headers" id="headers"><h2>Headers</h2></a>
<p>All the files in Dat's Storage are considered SLEEP files. However, not all
files require a header. Only the files that have a variable algorithm (such as
hashing, signing) require a SLEEP header.</p>
<a class="header" href="#usage-in-dat" id="usage-in-dat"><h2>Usage in Dat</h2></a>
<p>When you append data, you basically update the Merkle Tree. Updating the Merkle
Tree creates a new Root Hash of the Merkle Tree. For security we need to sign
this Root Hash, so people can trust it's the new one.</p>
<p>It's important to know that everything in Hypercore is a byproduct of appending
data to the Feed. This includes Signatures, Hashes, Root Nodes and more.</p>
<a class="header" href="#types-of-storage" id="types-of-storage"><h3>Types of Storage</h3></a>
<ul>
<li><strong>data:</strong> The concatenated data that was appended to the feed.</li>
<li><strong>merkle tree:</strong> The hashes of the data, and hashes of hashes of data - stored
in a tree. Also stores the length of the datta.</li>
<li><strong>signatures:</strong> We take the Root Hash of the Merkle Tree, and sign that one.</li>
<li><strong>bitfield:</strong> Space-efficient data structure used to figure out which data you
have and what data you don't.</li>
<li><strong>key:</strong> Ed25519 Public Key (part of a keypair).</li>
<li><strong>secret key:</strong> Ed25519 Secret Key (part of a keypair).</li>
</ul>
<p>When you produce a new Signature, the index for the Signature is the same index
as for the data you appended to the Feed.</p>
<a class="header" href="#implementation-guide" id="implementation-guide"><h1>Implementation Guide</h1></a>
<a class="header" href="#appendix" id="appendix"><h1>Appendix</h1></a>
<a class="header" href="#a---terminology" id="a---terminology"><h1>A - Terminology</h1></a>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
